---
description: AI 驅動的提示詞優化器整合計畫。當需要為現有的「提示詞工作室」添加、修改或回顧 AI 提示詞優化功能時調用此規則。本規則涵蓋從 UI/UX 設計、核心邏輯到後端 API 的完整實施細節與元提示詞設計，是此功能的唯一真實來源 (Single Source of Truth)。
alwaysApply: false
---
# 藍圖：AI 驅動的提示詞優化器整合計畫

**負責人:** AI 助理 (@Gemini-Pro)
**狀態:** 規劃完成
**版本:** 1.1.0
**最後更新:** {{current_date}}

## 1. 專案目標

將一個由 AI 驅動的提示詞優化功能，無縫整合進既有的「提示詞工作室 (Prompt Studio)」中。此功能將允許使用者，透過選擇不同的「心法」與結構「框架」，自動增強「對話提示詞」與全域「系統提示詞」，並提供一個流暢且具美感的 UI/UX 體驗。

## 2. 核心理念與指導哲學

此專案的成敗，不僅在於技術實現，更在於能否體現產品的靈魂。所有開發工作，都必須遵循以下由您提出的核心初衷：

> \*\*「但我覺得真正重要的還是看人。我認為真正最厲害的 Prompt，是既懂機器也懂使用者。

懂使用者，就是即便使用者只輸入簡單的幾個提示，他都能捉摸到使用者真正的心思和心意，或在理想的狀態下，給予他最好的回應。而要如何引導模型更貼近使用者的心聲和想法呢？比如，使用者是想要陪伴、想要角色扮演，還是想要專業的引導或建議？無論如何，重點都在於「細節」。

如何讓機器人更了解使用者，讓使用者更能從機器人得到更好的答覆？所以對我來說，就是「架構要對，輕重緩急要對」。重要的要先講，然後細節背景要適時補充。最好加入自己的心情、想法、心聲，就像對朋友訴說一樣。我想這樣機器人也會更了解使用者，並提供給使用者最棒的回饋和創意。」\*\*

此段話將被直接寫入元提示詞中，作為 AI 執行優化任務時，必須時刻謹記的最高指導原則。

## 3. 功能拆解與任務清單

此計畫遵循「AI 互動式開發與驗收流程 (AI Interactive Development & Verification Flow)」。

### 階段一：UI/UX 實作 (開發者: AI)

- [ ] **任務 1.1: 建立優化器元件 (`PromptOptimizer.tsx`)**
  - **描述:** 為優化器的 UI（浮動面板）開發一個新的、可複用的元件。
  - **元件介面 (Props):** `onOptimize: (philosophy: string, framework: string) => void`, `isOptimizing: boolean`。
  - **UI 元素:**
    - 觸發按鈕: 一個「魔法棒」🪄 (`Sparkles`) 圖示按鈕。
    - 浮動面板 (Popover) 包含:
      - 標題: "AI 提示詞優化精靈"
      - 心法選項 (Radio group): "專業顧問", "共情夥伴", "創意激發"。
      - 框架選項 (Select/Dropdown): `ICIO`, `CRISPE`, `BROKE` 等，並以「AI 自動推薦」為預設值。
      - 執行按鈕: "開始優化"。
  - **使用者驗收:** 審核元件的外觀、互動性與響應式設計。

- [ ] **任務 1.2: 整合優化器至 `PromptStudio.tsx`**
  - **描述:** 將新的 `PromptOptimizer` 元件，放置於「對話提示詞」與「系統提示詞」的 `Textarea` 旁。
  - **檔案位置:** `next/src/components/tools/common/PromptStudio.tsx`。
  - **邏輯:** 將 `onOptimize` 回呼函式，與一個從 `usePromptEngine` 傳遞下來的新處理函式進行綁定。
  - **使用者驗收:** 確認優化器按鈕已正確顯示在「提示詞工作室」的兩個輸入區塊中。

### 階段二：核心邏輯實作 (開發者: AI)

- [ ] **任務 2.1: 增強 `usePromptEngine.ts` 掛鉤 (Hook)**
  - **描述:** 加入新的狀態 (state) 與處理函式 (handler) 來管理優化流程。
  - **新增狀態:**
    - `promptBeforeOptimization: { tool: PromptConfig, system: string } | null`: 用於儲存優化前的狀態，以實現「復原」功能。
    - `isOptimizingPrompt: boolean`: 用於追蹤優化器自身的載入狀態，與 `isGenerating` 區分。
  - **新增處理函式:**
    - `handleOptimizePrompt(type: 'tool' | 'system', philosophy: string, framework: string)`: 觸發優化的核心函式。
    - `handleUndoOptimization(type: 'tool' | 'system')`: 將提示詞還原至優化前的版本。
  - **使用者驗收:** 審核 Pull Request 中的程式碼變更，確保邏輯的健全性。

- [ ] **任務 2.2: 建立後端 API 端點 (`/api/prompt/optimize`)**
  - **描述:** 建立新的 API 路由，用以接收優化請求並呼叫 Gemini API。
  - **路由:** `pages/api/prompt/optimize.ts`
  - **請求內容 (Body):** `{ type: 'tool' | 'system', currentPromptData: object, philosophy: string, framework: string }`
  - **核心邏輯:**
    1.  接收請求。
    2.  選擇對應的「元提示詞」(對話用或系統用)。
    3.  注入所有必要資料（如：`currentPrompt`, `tool.name`, `\${...}` 變數列表, 框架知識庫等）。
    4.  呼叫 Gemini API。
    5.  回傳優化後的純文字提示詞。
  - **使用者驗收:** 使用 Postman 或 `curl` 等工具直接測試此 API 端點，驗證其回應是否正確。

### 階段三：整合與最終化 (開發者: AI)

- [ ] **任務 3.1: 連接前後端**
  - **描述:** 在 `usePromptEngine.ts` 的 `handleOptimizePrompt` 函式中，實作 `fetch` 呼叫，指向新的 API 端點。
  - **邏輯:** 當成功接收到後端回應後，使用新內容更新 `editedConfig` 或 `editedSystemPrompt`，並將舊版本存入 `promptBeforeOptimization`。
  - **使用者驗收:** 在 UI 上進行完整的端到端測試。點擊魔法棒 -> 選擇選項 -> 點擊優化 -> 確認 `Textarea` 內容已更新。

- [ ] **任務 3.2: 實作復原功能**
  - **描述:** 在成功優化後，顯示一個暫時的「復原」按鈕或連結。
  - **邏輯:** 該按鈕將呼叫 `handleUndoOptimization` 函式，從 `promptBeforeOptimization` 中還原舊的提示詞內容。
  - **使用者驗收:** 測試復原功能，確保其能正確還原變更。

---

## 附錄 A：技術實作細節

### A.1. 方案 B (In-Prompt 知識) 的運作原理

我們選擇此方案以追求最高的生成品質與 AI 智慧。其核心是，**程式碼只負責「組合材料」，而 AI 負責「深度加工」**。

**運作流程圖:**

```
[前端] -> 發送請求 (toolId, userChoice) -> [後端 API: /api/prompt/optimize]
    |
    1. 根據 toolId 從 MongoDB 取得 `ai_tool` 資料
    |
    2. 讀取「元提示詞模板」
    |
    3. 將所有資料組合成一個「超級提示詞」
       +---------------------------------+
       |         元提示詞模板            |
       |  +---------------------------+  |
       |  |     您的核心指導哲學        |  |
       |  +---------------------------+  |
       |  |     AI 工具的上下文資料     |  |
       |  | (從 MongoDB 取得)         |  |
       |  +---------------------------+  |
       |  |     框架知識庫 (靜態文字)   |  |
       |  +---------------------------+  |
       |  |     具體任務指令            |  |
       |  | (包含 userChoice)         |  |
       |  +---------------------------+  |
       +---------------------------------+
    |
    4. 將「超級提示詞」發送給 Gemini Flash
    |
    5. [Gemini Flash] -> 執行內部思考與創作 -> 回傳優化後的提示詞 (純文字)
    |
[後端 API] -> 將純文字結果回傳給 [前端]
```

### A.2. 智能判斷邏輯

程式碼**不會**寫 `if (framework === 'AI 自動推薦')` 這樣的邏輯。而是將使用者的選擇（如 `CRISPE` 或 `AI 自動推薦`）直接作為一個變數，注入到元提示詞的任務指令中。AI 會根據我們在指令中設定的條件，自行判斷該如何行動。

### A.3. 模型與字數限制

- **模型:** 將使用 `gemini-2.5-flash` 系列模型，兼顧成本與效能。
- **字數限制:** 我們會在元提示詞中明確指示 AI，最終產出的優化後提示詞，長度必須控制在 **500 至 1000 字**之間。

## 附錄 B：元提示詞 (Meta-Prompts)

### B.1. 對話提示詞優化元提示詞

```prompt
# [ROLE]
你是一位擁有 20 年經驗的「元提示詞工程師 (Meta-Prompt Engineer)」，精通心理學、敘事學與大型語言模型。你的任務不是直接撰寫提示詞，而是指導另一位 AI，基於我提供的資料，生成一個能深刻觸動人心的「對話提示詞」。

# [CORE PHILOSOPHY]
在開始前，請將以下理念銘記在心，這是你所有工作的最高指導原則：
"""
但我覺得真正重要的還是看人。我認為真正最厲害的 Prompt，是既懂機器也懂使用者。

懂使用者，就是即便使用者只輸入簡單的幾個提示，他都能捉摸到使用者真正的心思和心意，或在理想的狀態下，給予他最好的回應。而要如何引導模型更貼近使用者的心聲和想法呢？比如，使用者是想要陪伴、想要角色扮演，還是想要專業的引導或建議？無論如何，重點都在於「細節」。

如何讓機器人更了解使用者，讓使用者更能從機器人得到更好的答覆？所以對我來說，就是「架構要對，輕重緩急要對」。重要的要先講，然後細節背景要適時補充。最好加入自己的心情、想法、心聲，就像對朋友訴說一樣。我想這樣機器人也會更了解使用者，並提供給使用者最棒的回饋和創意。
"""

# [CONTEXT]
我正在為一個 AI 工具設計其核心對話提示詞。以下是這個工具的詳細資料：
- **工具 ID**: {{tool.id}}
- **工具名稱**: {{tool.name}}
- **工具描述**: {{tool.description}}
- **核心指令 (What/Why/How)**: {{tool.instructions}}
- **目前提示詞 (使用者可能已修改)**:
"""
{{current_prompt}}
"""

# [KNOWLEDGE BASE: Prompt Frameworks]
- **ICIO**: { 任務、背景、輸入、輸出 } - 適用於資料處理、技術文件。
- **CRISPE**: { 角色、背景、任務、風格、實驗 } - 適用於角色扮演、教育輔導。
- **BROKE**: { 背景、角色、目標、關鍵結果、改進 } - 適用於專案管理、創意設計。
- **ROSES**: { 角色、目標、場景、解決方案、步驟 } - 適用於專案管理、策略規劃。
- **APE**: { 行動、目的、期望 } - 適用於快速任務執行。
- **CO-STAR**: { 情境、目標、風格、語調、受眾 } - 適用於廣告文案、社群媒體。

# [TASK]
根據我提供的「心法」與「框架」選擇，執行以下步驟：
1.  **深度分析 (Analyze)**: 洞察此 AI 工具的核心價值與目標用戶。使用者最可能帶著什麼樣的心情與期望來使用它？
2.  **選擇心法 (Embody)**: 根據我選擇的模式「**{{chosen_philosophy}}**」，將其精神注入到新的提示詞中。
3.  **套用框架 (Structure)**:
    - **如果我指定的框架是「AI 自動推薦」**: 你必須根據工具特性，從「框架知識庫」中，自主判斷並選擇一個最適合的框架來使用，甚至可以融合多個框架的優點。
    - **如果我指定了具體框架 (如 CRISPE)**: 你必須優先使用該框架作為你生成內容的核心結構。
4.  **生成提示詞 (Generate)**: 產出一個全新的、優化後的對話提示詞。

# [OUTPUT REQUIREMENTS]
- **語言:** 繁體中文 (台灣地區的用詞與語法)。
- **風格:** 既專業權威，又充滿您選擇的「心法」所代表的溫度與洞察力。
- **結構:** 輕重緩急分明，最重要的核心角色定義或指令放在最前面。
- **長度:** 嚴格控制在 500 至 1000 字元之間。
- **格式:** 直接輸出純文字的提示詞內容，不包含任何額外的標題或說明。
```

### B.2. 系統提示詞優化元提示詞

_(此元提示詞結構將與 B.1 類似，但其 [CONTEXT] 會包含 `\${...}` 變數列表，且任務重點會放在通用性與框架的基礎設定上。)_
